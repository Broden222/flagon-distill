
============
Segmentation
============

The Segment Object
------------------
`Segment` objects represent the metadata associated with a segment of UserAle logs.  Each object has a variety of fields, including:

* ``segment_name``: The given name of a segment
* ``start_end_val``: The start and end ``clientTime``'s of a segment
* ``num_logs``: The number of logs in a segment
* ``uids``: A list of the UIDs of the logs within the segment
* ``segment_type``: An enumerated type (``Segment_Type``) that denotes how the segment was created
* ``generate_field_name``: The field name used for value-matching if a segment was created through segment generation (`generate_segments`)
* ``generate_matched_values``: The values used for value-matching if a segment was created through segment generation (`generate_segments`)

These fields can be accessed through `get` functions.  For example, if a dictionary of segments is created using the ``generate_segments`` function:
::
    generated_segments = distill.generate_segments(sorted_dict, 'type', ['clicks'], 1, 1)
then the number of logs in each of these segments could be printed to the console by running:
::
    for segment_name in generated_segments:
        print(generated_segments[segment_name].get_num_logs())
.. note ::
    These functions are called via the ``Segment`` object itself, following the pattern ``segment.get_...()``

Segment Creation
----------------
The creation of segments can be done through the use of three functions: ``create_segment``, ``generate_segments``, and ``detect_deadspace``.

Create Segment
**************
The most literal way to create a segment is through the use of the ``create_segment`` function.  This function takes in three parameters in order to create segments: a target dictionary of UserAle logs, a list of segment names, and a list of tuples that represent the start ``clientTime`` and end ``clientTime`` of the segment.  Given this information, segments can be created as follows:
::
    # Sorted dictionary of UserAle logs
    sorted_dict

    # List of segment names
    segment_names = ["segment1", "segment2"]

    # Time tuples
    start_end_vals = [(start_time_1, end_time_1), (start_time_2, end_time_2)]

    # Create Segments
    segments = distill.create_segment(sorted_dict, segment_names, start_end_vals)

The above code will output a dictionary of ``segment_name`` to ``Segment`` objects following the respective order of the segment names and start/end tuples.  For instance, we can access the first segment by doing the following:
::
    segment1 = segments["segment1"]

Generate Segments
*****************
Segment generation is a more automatic way to create segments and is based off of the matching of a particular UserAle log field with a list of possible values.  The function ``generate_segments`` will then generate segments based on windows of time starting before and after the matched field, indicated in seconds as a function parameter.  The below code illustrates the basic use of this function:
::
    # Sorted dictionary of UserAle logs
    sorted_dict

    # Generate segments based on user clicks
    segments = distill.generate_segments(sorted_dict, 'type', ['click'], 1, 2)

The above code will create segments that represent windows of time 1 second prior to a 'click' type and 2 seconds after a 'click' type.  If we wanted to generate segments that matched both 'click' and 'load' types, then we could use the following code:
::
    # Sorted dictionary of UserAle logs
    sorted_dict

    # Generate segments based on user clicks and loads
    segments = distill.generate_segments(sorted_dict, 'type', ['click', 'load'], 1, 2)

.. note::
    ``generate_segments`` does not overlap segments.  In the event that two matching events happen back-to-back within the logs and the second log is already in the segment generated by the first, the second segment will not have its own segment created.  This non-overlapping behavior also may create segments that are shorter in time than expected.  For instance, if a segment is created with an end time that is after the start time of a new segment, the new segment's start time will default to the end time of the previous segment.

Detect Deadspace
****************
Another way to create segments is to do so based on deadspace in the UserAle logs.  Deadspace is simply time in which the user is idle.  The ``detect_deadspace`` function creates segments based on deadspace in the logs given a threshold for what is considered to be 'deadspace'.  An example of this is shown below:
::
    # Sorted dictionary of UserAle logs
    sorted_dict

    # Create segments based on detected deadspace
    segments = distill.detect_deadspace(sorted_dict, 20, 1, 2)

The above code will output a dictionary of segment names to ``Segment`` objects that represent deadspace segments.  In this case, we have defined 'deadspace' to be any idle time of 20 seconds.  Each time deadspace is detected, the logs that occurred 1 second before and 2 seconds after that idle time are recorded in the segment.

Combining Segments with Set Logic
---------------------------------
Segments can be combined to create set logic


You can perform union on the following:
::
    uids = segment1.uids
    for uid in segment2.uids:
        if uid not in uids:
            uids.append(uid)

.. note::
    A new segment with the given segment_name, start and end values based on the smallest client time and
    largest client time of the given segments, and a list of the union of the uids of segment1 and segment2.



You can perform intersection on the following:
::
    uids = []
    for uid in segment2.uids:
        if uid in segment1.uids:
            uids.append(uid)
.. note::
    A new segment with the given segment_name, start and end values based on the smallest client time and
    largest client time of the given segments, and a list of the intersection of the uids of segment1 and segment2.

Writing Segments
----------------
Write Segment creates a nested of segment names to UIDs which then map to individual logs (i.e result['segment_name'][uid] --> log). This assists with easy iteration over defined segments
::
    result = {}
    create_result = create_segment(target_dict, segment_names, start_end_vals)

    # Iterate through segments to get logs
    for segment_name in create_result:
        result[segment_name] = {}
        for uid in create_result[segment_name].uids:
            result[segment_name][uid] = target_dict[uid]

    return result
.. note::
    A nested dictionary of segment_names to uids to individual log

Exporting Segments
------------------
Segments can be exported into csv files using the ``export_segments`` function.  This function will take the path to place the new file along with a dictionary of segment objects (matching the form outputted by the segment creation functions) and output a new csv with each segment on a new line.
